1.写出了文法的产生式，便于利用递归下降子程序分析

PROGRAM -> int main SUB_PROGRAM.
SUB_PROGRAM -> {STATEMENT_TABLE BACK}
STATEMENT_TABLE -> ASSIGNMENT_STATEMENT STATEMENT_TABLE|VARIABLE STATEMENT_TABLE
ASSIGNMENT_STATEMENT ->id = ARITHMETIC_EXPRESSION;
ARITHMETIC_EXPRESSION -> ARITHMETIC_EXPRESSION w0 TERM|TERM
TERM -> TERM w1 FACTOR|FACTOR
FACTOR -> id|cons|(ARITHMETIC_EXPRESSION)
VARIABLE -> TYPE ID_TABLE;
TYPE -> int|float|char
ID_TABLE -> id {,id}
BACK -> return BACK_NUM
BACK_NUM -> id|cons

2.写出了基本的函数框架，包括扫描器和语法分析部分，但是运行存在一些问题，有点困难，整体上属于对老师所给pascal例程的类c改写，主函数的写法还在斟酌当中

#include <iostream>
#include <cmath>
#include <cstring>
#include <fstream>

using namespace std;

#define N 18

//类c常数自动机
int c_aut[8][5]={2,0,0,0,0,2,3,5,8,8,4,0,0,0,0,4,0,5,8,8,
7,0,0,6,0,7,0,0,0,0,7,0,0,8,8,0,0,0,0,0};   //状态转换矩阵

//关键字
char Keys[N][15]={"int","main","float","char","return",".","{","}","=",";"
,"(",")",",","+","-","*","/"};


struct SemRecord                      //符号表结构
{   char name[15];
};


/*
编码规则：
标识符  1
常数  2
int 3
main 4
float 5
char 6
return 7
.   8
{   9
}   10
=   11
;   12
(   13
)   14
,   15
+   16
-   17
*   18
/   19
*/



//token结构
struct wordinfo{
    int code;
    int value;
};


//类c常数自动机定义

class c_cons                      
{
     private:
	    int aut[8][5];                   //状态转换矩阵
        int s;                           //当前状态
        int n,p,m,e,t;                   //尾数值，指数值，小数位数，指数符号，类型
        double num;                      //常数 
		char ch;                         //当前符号 
	 public:
		 c_cons();
		 double number(char *line,int *p);      //拼一个常数
	 private:
        void ProcError();
        int map(char ch);
        int find(int s, char ch);
        void act(int s, char ch);
};

//扫描器
class Scan                                 
{
    private:
        char *keywords[N];                 //关键字表、界符表
        char line[50];                       //当前行
	    int i_line;
	    char ch;                               //当前字符
        char strToken[15];                     //当前单词
	    int i_str;
        int code,value;
        int i;
        c_cons num;                        //常数对象

        SemRecord *p_ID;                        //符号表指针
        int *p_m;
        double *p_Cons;                           //常数表指针
        int *p_n;
        ifstream fin;                           //源程序文件

	public:
		Scan();
		Scan(SemRecord *p1,int *p2,double *p3,int *p4);
		void Read(wordinfo *token);                          //read(w)
		int openfile(char *filename);

	private:
        void ProcError();
        int IsLetter(char ch);
        int IsDigit(char ch);
        int Reserve(char *strToken);
        int InsertID(char *strToken);
        int InsertConst(double num);
};



//递归子程序分析类
class Syntax                                  
{
    private:
        wordinfo token;                        //单词Token
        Scan sExam;                             //扫描器对象

	public:
		Syntax();
		Syntax(SemRecord *p1,int *p2,double *p3,int *p4);
        void Parse();

	private:
        void PROGRAM();                         //主程序
        void SUB_PROGRAM();                     //分程序
        void STATEMENT_TABLE();                 //语句表
        void ASSIGNMENT_STATEMENT();            //赋值语句
        void ARITHMETIC_EXPRESSION();           //表达式
        void TERM();                            //项
        void FACTOR();                          //因子
        void ARITHMETIC_QUANTITY();             //算术量
        void VARIABLE();                        //变量说明
        void TYPE();                            //类型定义
        void ID_TABLE();                        //标识符表
        void BACK();                            //返回
        void BACK_NUM();                        //返回值
        int map(int code);
};


//类c常数处理机类成员定义

c_cons::c_cons()
{
	int i,j;
	for (i=0;i<8;i++)                          //初始化自动机矩阵
		for (j=0;j<5;j++)
			aut[i][j]=c_aut[i][j];
	ch=' ';
};

void c_cons::ProcError()
{
	cout<<"err!"<<endl;
}; 

int c_cons::map(char ch)                    
{  int j;
   if (ch>='0' && ch<='9')
       j=0; 
   else if (ch=='.')
       j=1;
   else if (ch=='E'||ch=='e')
	   j=2; 
   else if (ch=='+'||ch=='-')
	   j=3; 
   else
       j=4; 
   return j;
}

int c_cons::find(int s, char ch)           //s---当前状态；ch---当前符号
{  int i,j;                     //行和列
   i=s-1;                    //将s映射到行标记i
   j=map(ch);                //将ch映射到列标记j
   return aut[i][j];            //返回下一个状态值
}

void c_cons::act(int s, char ch)
{  
	switch (s)
	{
		case 1: n=0; m=0; p=0; t=0; e=1; num=0;     break;
        case 2: n=10*n+ch-48;	                  break;
        case 3: t=1;              	  	          break;
        case 4: n=10*n+ch-48;    m++;           break;
        case 5: t=1;             		          break;
        case 6: if (ch=='-') e=-1; 		          break;
        case 7: p=10*p+ch-48;  		          break;
        case 8: num=n*pow(10,e*p-m);            
	}
}

double c_cons::number(char *line,int *p)              //拼一个常数
{
    s=1;
    act(s,ch);                     //执行q1
    while (s!=8)
    {  
     	ch=line[*p];               //读取当前符号到ch中
		(*p)++;
        s=find(s,ch);               //查状态表  
		if (s==0)
			break;
        act(s,ch);                  //执行qs
    }
    if (s==8)
        return num;                 //输出num
    else
	{
        ProcError();
		return 0;      //错误处理
	}
};


//扫描器类成员定义
Scan::Scan(SemRecord *p1,int *p2,double *p3,int *p4)
{
     p_ID=p1;                       //扫描器用符号表和常数表的指针初始化       
     p_m=p2;
     p_Cons=p3;                         
     p_n=p4;

     int i;
	 for (i=0;i<N;i++)              //初始化关键字表
        keywords[i]=Keys[i];

	 i_line=0;
     line[i_line]='\0';
};

int Scan::openfile(char *filename)
{
    fin.open(filename);
	if (!fin)
	{
		cout<<"Can't open input file.\n";
		return 0;
	}
	return 1;
};

void Print(struct wordinfo token)                      //输出Token
{
	printf("(%d %d)",token.code,token.value);
}

void Scan::ProcError()
{
	printf("err!");
}

int Scan::IsLetter(char ch)                       //判断ch是否为字母
{  if (ch>='A' && ch<='Z' || ch>='a' && ch<='z')
       return 1;
   else 
       return 0;
}

int Scan::IsDigit(char ch)                       //判断ch是否为数字
{  if (ch>='0' && ch<='9')
       return 1;
   else 
       return 0;
}

int Scan::Reserve(char *strToken)              
//用strToken中的单词去查关键字表。查到了，则返回该关键字的编码；
                   //否则，返回0
{   int i=0;
    while (i<N)                               //设N为关键字表中元素的个数
    {  if (!strcmp(keywords[i], strToken))
           return (i+3);
       i++;
     }
     return 0;
}

int Scan::InsertID(char *strToken)              
//用strToken中的单词去查符号表。查到了，则返回该单词在表中的位置值；
                    //否则，将strToken中的单词插入符号表的尾部，并返回位置值
{   int i=0;
    while (i<*p_m)                            //设m为符号表中已有的标识符的个数
    {   if (!strcmp((p_ID+i)->name, strToken))
           return i;
        i++;
     }
     strcpy((p_ID+i)->name,strToken);
     (*p_m)++;
     return i;
}

int Scan::InsertConst(double num)             
 //用拼好的num去查常数表。查到了，则返回该单词在表中的位置值；
                            //否则，将num插入常数表的尾部，并返回位置值
{   int i=0;
    while (i<*p_n)                            //设n为常数表中已有的常数的个数
    {  if (p_Cons[i]==num)
           return i;
       i++;
     }
     p_Cons[i]=num;
     (*p_n)++;
     return i;
}

void Scan::Read(wordinfo *token)
{
    double const_num;                                //常数值变量

    if (line[i_line]=='\0')                          //当行缓冲区空时，读入一行                
	{
		if (fin.getline(line,50,'\n'))                //读到了一行
		    i_line=0;
		else
		{
            token->code=0;                        //文件结束，返回Token（0，-1）
            token->value=-1;
		    return;
		}
	};

	ch=line[i_line++];                            //读取当前单词的第一个符号到ch中

    while (ch==' ')                                  //滤除空格
        ch=line[i_line++];

	i_str=0;
		                           
  	if (IsLetter(ch))
	{
        while (IsLetter(ch)||IsDigit(ch))       //拼关键字或标识符
		{   strToken[i_str++]=ch;               //将ch中的字符拼接到strToken中
            ch=line[i_line++];                   //读取当前字符到ch
		}
		i_line--;                                //Retract()
		strToken[i_str]='\0';
        code=Reserve(strToken);                   //查关键字表；
        if (!code)                                //未查到，是一个标识符
		{
            value=InsertID(strToken);            //将strToken中的单词插入到符号表中
            token->code=1; 
            token->value=value;
		}
        else
		{
            token->code=code; 
            token->value=-1;
		}
	} 
    else if (IsDigit(ch))                           //处理常数
	{
        i_line--;
		const_num=num.number(line,&i_line);         //拼常数到const_num中     		 
		i_line--; 

        value=InsertConst(const_num);           //将const_num中的常数插入到常数表中
        token->code=2; 
        token->value=value;
	}
    else                                       //  处理界符或错误处理；
	{
        strToken[i_str++]=ch;                    //将ch中的字符拼接到strToken中；
        if (ch==':')                             //    处理双界符":="；
		{
             ch=line[i_line++];
             if (ch=='=')
                 strToken[i_str++]=ch;
             else
                 i_line--;                         //回溯一个字符
		}
        strToken[i_str]='\0';
        code=Reserve(strToken);              //查界符表
        if (!code)                          //未查到 
             ProcError();                //错误处理
        else                            //生成并输出一个界符Token；
		{
             token->code=code; 
             token->value=-1;
		}
	}
};



//语法分析类成员定义
Syntax::Syntax(SemRecord *p1,int *p2,double *p3,int *p4):sExam(p1,p2,p3,p4)
{
};

void Syntax::Parse()
{
	char filename[15];                             //文件名区

	printf("please input file name:");             //输入文件名
    scanf("%s",filename); 
	
    if (!sExam.openfile(filename))                 //打开文件
		return;

	sExam.Read(&token);                                    //read(w)
    PROGRAM();      
	if (!token.code)                                       //‘#’的Token为(0,-1)
		printf("OK!");
	else
		printf("err");
};

void Syntax::PROGRAM()
{
    if (token.code == 3)                     //int 
    {
        sExam.Read(&token);
        if (token.code == 4)                  //main
        {
            sExam.Read(&token);
            SUB_PROGRAM();
            if (token.code == 8)             //.
            {
                sExam.Read(&token);
            }
            else
                cout<<"error!";
        }
        else 
            cout<<"error!";
    }
    else
        cout<<"error!";
};

void Syntax::SUB_PROGRAM()              //分程序
{
    if (token.code == 9)                 //{
    {
        sExam.Read(&token);
        STATEMENT_TABLE();
        BACK();
        if (token.code == 10)              //}
        {
            sExam.Read(&token);
        }
        else 
            cout<<"error!";
    }
    else 
        cout<<"error!";
};

void Syntax::STATEMENT_TABLE()                //语句表
{
    if (token.code == 1)                //id
    {
        ASSIGNMENT_STATEMENT();
        STATEMENT_TABLE();
    }
    else
    {
        VARIABLE();
        STATEMENT_TABLE();
    }  
};
void Syntax::ASSIGNMENT_STATEMENT()            //赋值语句
{
    if (token.code == 1)                  //id
    {
        sExam.Read(&token);
        if (token.code == 11)               //=
        {
            sExam.Read(&token);
            ARITHMETIC_EXPRESSION();
        }
        else
            cout<<"error!";
    }
    else 
        cout<<"error!"; 
};

int Syntax::map(int code)
{
	int i;
	switch (code)
	{
	    case 16:i=0;break;                  // +
	    case 17:i=0;break;                  // -
		case 18:i=1;break;                  // *
		case 19:i=1;break;                  // /
		case 1: i=2;break;                  //标识符
		case 2: i=2;break;                  //常数
		case 13:i=3;break;                   //(
		case 14:i=4;break;                   //)
		default:i=5;                         //-1符号
	}
	return i;
}


void Syntax::ARITHMETIC_EXPRESSION()                //算术表达式
{
	int n=7;                                      //产生式个数
	wordinfo syn[15];                            //语法栈
	int top;                                     //栈顶指针
    int top_in;                                  //移进指针
    int handle[10];                              //<栈
    int top_h;                                   //<栈顶指针
	int prio[6][6]={3,1,1,1,3,3,
	                3,3,1,1,3,3,
                    3,3,0,0,3,3,
					1,1,1,1,2,0,
					3,3,0,0,3,3,
					1,1,1,1,0,4};              //优先分析表                             
	int i,j;                                    //表行和列
	int code;                                  //表项
int rules[7][5]={{-1,16,-1},{-1,17,-1},{-1,14,-1},{-1,15,-1},{1},{2},{19,-1,20}};
 //产生式表,-1表示空位（非终结符的占位）
    
	syn[0].code=0;
	top=0; top_in=1;
	handle[0]=0;
	top_h=0;

	while (1)
	{
		//查分析表code=prio(i,j)
        i=map(syn[top].code);              //定位行和列
        j=map(token.code);
        code=prio[i][j];                //查表
		//空或OK
		if (code==0 || code==4)
			break;
		//栈操作和输入操作
		if (code<3)                                 //< or =
		{
            syn[top_in].code=token.code;                //进栈
            syn[top_in].value=token.value;
            if (code==1)                         //记录句柄的左端位置
               handle[++top_h]=top+1; 
            top=top_in++;
            sExam.Read(&token);                          //read(w)	
		}
		else                                        //>
		{
           for (i=0;i<n;i++)                          //比较产生式
		   {
			   j=0;
			   while (rules[i][j] && rules[i][j]==(syn+handle[top_h]+j)->code)
				   j++;
			   if (!rules[i][j] && handle[top_h]+j==top_in)       //匹配上了一个
				   break;
		   }
           if (i==n)
             printf("error!");
           else
           {
               syn[handle[top_h]].code=-1;                            //归约
               top= handle[top_h]-1;
               top_in= handle[top_h]+1;
               top_h--;
            }
		}

	}
	if (!code)
		printf("error!");
}
void Syntax::VARIABLE()                        //变量说明
{
    TYPE();
    ID_TABLE();
};
void Syntax::TYPE()                            //类型定义
{
    switch (token.code)
    {
    case 3:                                      //int
    case 5:                                      //float
    case 6:      sExam.Read(&token);break;        //char
    default:cout<<"error!";
    }
};

void Syntax::ID_TABLE()                        //标识符表
{
	if (token.code== 1)                                 //标识符
	{
        sExam.Read(&token);
		while (token.code== 15)                         //,
		{
            sExam.Read(&token);
			if (token.code== 1)                         //标识符
              sExam.Read(&token);
			else
				cout<<"error!";
		}
	}
	else
		cout<<"error!";
};
void Syntax::BACK()                            //返回
{
    if (token.code == 7)                       //return
    {
        BACK_NUM();
    }
    else
        cout<<"error!";
};
void Syntax::BACK_NUM()                        //返回值
{
    switch (token.code)
    {
    case 1:                                   //id
    case 2:  sExam.Read(&token);break;        //常数
    default:cout<<"error!";
    }
};

int main()
{
    
}
